---
layout: single
title: "Promise와 Generator 함수를 이용한 비동기처리"
categories: [JavaScript]
tag: [promise, generator]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## 비동기 처리에는 다양한 방법들이 있다.

1.  **callback(콜백) 함수**

   코드양이 많아지면 가독성이 떨어지고 복잡해진다.

   ```js
   //1
   setTimeout(
       (x) => {
           let result = x;
           console.log(result); // 10
           //2
           setTimeout(
           	(x)=>{
                   result *= x; 
                   console.log(result); // 200
                   //3
                   setTimeout(
                   	(x)=>{
                           result *= x;
                           console.log(result) // 6000
                           //4
                           setTimeout(
                           	(x)=>{
                                   result *= x;
                                   console.log(result) // 240000
                               },
                               1000,
                               40
                           )
                       },
                       1000,
                       30
                   )
               },
               1000,
               20
           );
           
       },
       1000,
       10
   );
   ```

2. **Promise로 변환**

   promise를 사용해서 구현을 하면 좀 더 가독성 있게 편리하게 복잡하지 않게 필요한 만큼 작성해나갈 수 있다.

   - `new Promise()` 호출하여 대기 상태가 된다.
   - 이때, 콜백 함수를 선언할 수 있고 인자는 `resolve, reject`가된다.
   - 콜백 함수내에서 처리할거 처리한후에 `resolve()` 메서드를 호출하면 이행상태가 된다.
   - 즉, 성공이면 리턴 값을` then()` 이 받아서 계속 처리 수행한다.
     - promise를 사용하면 callback 함수보다 좀 더 수 

   ```js
   new Promise((resolve, reject) => {
       setTimeout(
       	(x)=>{
               let result = x;
               console.log(result);
               resolve(result);
           },
           1000,
           10
       );
   })
   .then((result) => {
       return new Promise((resolve, reject) => {
           setTimeout(
               (x)=>{
                   result*=x;
               	console.log(result);
               	resolve(result);
           	},
           	1000,
           	20
       	);
   	});
   })
   .then((result) => {
       return new Promise((resolve, reject)=> {
          setTimeout(
              (x)=>{
                  result*=x;
                  console.log(result);
                  resolve(result);
              },
              1000,
              30
          ); 
       });
   })
   .then((result) => {
       return new Promise((resolve, reject)=> {
          setTimeout(
              (x)=>{
                  result*=x;
                  console.log(result);
                  resolve(result);
              },
              1000,
              40
          ); 
       });
   });
   ```

3. **Generator로 변환**

   ```js
   const calc = (x, y) => {
       setTimeout(
           ()=>{
               iter.next(x*y);
           },
           1000
       )
   
   }
   
   function* testGen() {
   	const a = yield calc(1,10);
       console.log(a);
       
       const b = yield calc(a, 20);
       console.log(b);
       
       const c = yield calc(b, 30);
       console.log(c);
       
       const d = yield calc(c, 40);
       console.log(d);
   };
   const iter = testGen();
   iter.next();
   //iter.next(10) 10
   //iter.next(200) 200
   //iter.next(6000); 6000
   //iter.next(240000); 240000
   ```

   